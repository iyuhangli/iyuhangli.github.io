<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>做了一些微小的工作</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-12-31T15:28:05.627Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Yuhang Li</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于Windows运行YOLO和SSD的python代码提示No module named cv2和On entry to DGEBAL parameter number的问题</title>
    <link href="http://example.com/2020/12/29/%E5%85%B3%E4%BA%8EWindows%E8%BF%90%E8%A1%8CYOLO%E5%92%8CSSD%E7%9A%84python%E4%BB%A3%E7%A0%81%E6%8F%90%E7%A4%BANo%20module%20named%20%E2%80%98cv2%E5%92%8COn%20entry%20to%20DGEBAL%20parameter%20number%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2020/12/29/%E5%85%B3%E4%BA%8EWindows%E8%BF%90%E8%A1%8CYOLO%E5%92%8CSSD%E7%9A%84python%E4%BB%A3%E7%A0%81%E6%8F%90%E7%A4%BANo%20module%20named%20%E2%80%98cv2%E5%92%8COn%20entry%20to%20DGEBAL%20parameter%20number%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-12-29T20:29:33.000Z</published>
    <updated>2020-12-31T15:28:05.627Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python运行YOLO和SSD相关文件时报错"><a href="#Python运行YOLO和SSD相关文件时报错" class="headerlink" title="Python运行YOLO和SSD相关文件时报错"></a>Python运行YOLO和SSD相关文件时报错</h1><h5 id="提示ModuleNotFoundError-No-module-named-39-cv2-39"><a href="#提示ModuleNotFoundError-No-module-named-39-cv2-39" class="headerlink" title="提示ModuleNotFoundError: No module named &#39;cv2&#39;"></a>提示<code>ModuleNotFoundError: No module named &#39;cv2&#39;</code></h5><p><strong>解决方法：</strong><br>安装opencv-python。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></table></figure><h5 id="提示-On-entry错误"><a href="#提示-On-entry错误" class="headerlink" title="提示 **On entry错误"></a>提示 **On entry错误</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> ** On entry to DGEBAL parameter number  3 had an illegal value</span><br><span class="line"> ** On entry to DGEHRD  parameter number  2 had an illegal value</span><br><span class="line"> ** On entry to DORGHR DORGQR parameter number  2 had an illegal value</span><br><span class="line"> ** On entry to DHSEQR parameter number  4 had an illegal value</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"></span><br><span class="line">ImportError: numpy.core.multiarray failed to import</span><br></pre></td></tr></table></figure><p><strong>解决方法：</strong><br>numpy的1.19.4版本会报这个错误，卸载numpy之后安装1.19.3版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip uninstall numpy</span><br><span class="line">pip install numpy&#x3D;&#x3D;1.19.3</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Python运行YOLO和SSD相关文件时报错&quot;&gt;&lt;a href=&quot;#Python运行YOLO和SSD相关文件时报错&quot; class=&quot;headerlink&quot; title=&quot;Python运行YOLO和SSD相关文件时报错&quot;&gt;&lt;/a&gt;Python运行YOLO和SSD相</summary>
      
    
    
    
    <category term="问题记录" scheme="http://example.com/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="对象检测" scheme="http://example.com/tags/%E5%AF%B9%E8%B1%A1%E6%A3%80%E6%B5%8B/"/>
    
    <category term="YOLO" scheme="http://example.com/tags/YOLO/"/>
    
    <category term="SSD" scheme="http://example.com/tags/SSD/"/>
    
  </entry>
  
  <entry>
    <title>字符串中的第一个唯一字符 (Java)</title>
    <link href="http://example.com/2020/12/22/LeetCode%20387.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6%20(Java)/"/>
    <id>http://example.com/2020/12/22/LeetCode%20387.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6%20(Java)/</id>
    <published>2020-12-22T20:10:05.000Z</published>
    <updated>2020-12-22T20:11:03.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h1><p><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/">https://leetcode-cn.com/problems/first-unique-character-in-a-string/</a></p><h1 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h1><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s &#x3D; &quot;leetcode&quot;</span><br><span class="line">返回 0</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s &#x3D; &quot;loveleetcode&quot;</span><br><span class="line">返回 2</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>你可以假定该字符串只包含小写字母。<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1>indexOf和lastIndexOf的使用，判断字母第一次出现的位置和最后一次出现的位置是否相同。</li></ul><h1 id="需要注意的"><a href="#需要注意的" class="headerlink" title="需要注意的"></a>需要注意的</h1><ul><li>Todo：使用Hash的方法。<h1 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> first = s.indexOf(s.charAt(i));</span><br><span class="line">            <span class="keyword">int</span> last = s.lastIndexOf(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span>(first ==  last)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/first-unique-charact</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 287. 寻找重复数 (Java)（快慢指针法和二分法）</title>
    <link href="http://example.com/2020/05/26/LeetCode%20287.%20%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0%20(Java)%EF%BC%88%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E6%B3%95%E5%92%8C%E4%BA%8C%E5%88%86%E6%B3%95%EF%BC%89/"/>
    <id>http://example.com/2020/05/26/LeetCode%20287.%20%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0%20(Java)%EF%BC%88%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E6%B3%95%E5%92%8C%E4%BA%8C%E5%88%86%E6%B3%95%EF%BC%89/</id>
    <published>2020-05-26T14:30:05.000Z</published>
    <updated>2020-12-19T22:25:44.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h1><p><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">https://leetcode-cn.com/problems/find-the-duplicate-number/</a></p><h1 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h1><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。<br><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,4,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,1,3,4,2]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>不能更改原数组（假设数组是只读的）。</li><li>只能使用额外的 O(1) 的空间。</li><li>时间复杂度小于 O(n2) 。</li><li>数组中只有一个重复的数字，但它可能不止重复出现一次。<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1>因为数组中只有一个数字有重复项，可以把数组当成一个有环的链表，然后找到环的起点，这就和<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">LeetCode 142. 环形链表 II</a>一样了。使用<strong>快慢指针法</strong>。</li></ul><p>当然也可以使用<strong>二分法</strong>。</p><h1 id="需要注意的"><a href="#需要注意的" class="headerlink" title="需要注意的"></a>需要注意的</h1><ul><li>常数空间</li><li>平方的复杂度<h1 id="解法一：快慢指针法"><a href="#解法一：快慢指针法" class="headerlink" title="解法一：快慢指针法"></a>解法一：快慢指针法</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>, slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            <span class="keyword">if</span>(slow == fast) &#123;</span><br><span class="line">                fast = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(nums[slow] != nums[fast]) &#123;</span><br><span class="line">                    fast = nums[fast];</span><br><span class="line">                    slow = nums[slow];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> nums[slow];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快慢指针法思路"><a href="#快慢指针法思路" class="headerlink" title="快慢指针法思路"></a>快慢指针法思路</h2>假如有一个数组<code>[1,2,4,2]</code>，这时候就可以如果按照顺序遍历，就是<code>1242 42  42······</code>。<br>我们设置两个一快(fast)一慢(slow)两个指针，一个每次走两步，一个每次走一步，直到它们相遇。<br>此时再将 slow 放置到起点，两个指针每次同时移动一步，相遇的点就是答案。<br><img src="https://upload-images.jianshu.io/upload_images/23211257-636fcb670e50a0cb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/23211257-636fcb670e50a0cb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/png;base64,666" alt="示意图"></li></ul><h1 id="解法二：二分法"><a href="#解法二：二分法" class="headerlink" title="解法二：二分法"></a>解法二：二分法</h1><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &lt;= mid) &#123;</span><br><span class="line">                    cnt += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; mid) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分法思路"><a href="#二分法思路" class="headerlink" title="二分法思路"></a>二分法思路</h2><p>拿示例一举个例子：</p><p>[1,3,4,2,2]<br>此时数字在 1 到5 之间。</p><p>mid = (1 + 5) / 2 = 3<br>小于等于的3有4个，即(1,2,2,3)，1到3中肯定有重复的值。</p><p>mid = (1 + 3) / 2 = 2<br>小于等于的2有3个(1,2,2)，1到2中肯定有重复的值。</p><p>mid = (1 + 2) / 2 = 1<br>小于等于的1有1个(1)，2到2中肯定有重复的值<br>所以重复的数是 2。</p><p>另外这是一个反常规操作，用<code>时间换空间</code>，因为i我们一般都是用<code>空间换时间</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-the-duplicate-n</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="二分法" scheme="http://example.com/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 102. 二叉树的层序遍历 (Java)</title>
    <link href="http://example.com/2020/05/13/LeetCode%20102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%20(Java)/"/>
    <id>http://example.com/2020/05/13/LeetCode%20102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%20(Java)/</id>
    <published>2020-05-13T14:29:31.000Z</published>
    <updated>2020-12-19T22:25:33.014Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a></p><h1 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h1><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。<br><strong>示例 1:</strong><br>二叉树：<code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p><code>BFS</code>问题，使用队列逐层遍历</p><h1 id="需要注意的"><a href="#需要注意的" class="headerlink" title="需要注意的"></a>需要注意的</h1><ul><li>根节点是<code>[]</code>时，返回的不是<code>null</code>，而是<code>[]</code>。</li><li>要使用<code>poll</code>方法。<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1></li></ul><ol><li>新建一个<code>List&lt;List&lt;Integer&gt;&gt;</code> l来存放输出结果，新建一个队列用来存放每层的数据。</li><li>首先判断根节点是否为空，如果不为空，将根节点放入队列，此时队列size为<code>1</code>。<br>判断。</li><li>判断队列是否为空，若不为空，获取队列size值<code>number</code>，循环<code>number</code>次，每次循环都会将队列中的第<code>x</code>个元素（0&lt;x&lt;n+1)添加到一个<code>List l2</code>中，将第<code>x</code>个元素的左右节点添加到队列中，循环结束后，将<code>List l2</code>添加到<code> l</code>中。继续第三步操作，直到队列为空。</li><li>输出l。<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; l=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; q=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            q.add(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; l2=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> number=q.size();</span><br><span class="line">            <span class="keyword">while</span>(number&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode t=q.poll();</span><br><span class="line">                l2.add(t.val);</span><br><span class="line">                <span class="keyword">if</span>(t.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    q.add(t.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    q.add(t.right);</span><br><span class="line">                &#125;</span><br><span class="line">                number--;</span><br><span class="line">            &#125;</span><br><span class="line">            l.add(l2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="队列中poll-peek和element的区别"><a href="#队列中poll-peek和element的区别" class="headerlink" title="队列中poll,peek和element的区别"></a>队列中poll,peek和element的区别</h1></li></ol><p><strong>为什么要使用<code>poll</code>方法操作队列呢？</strong><br><strong>共同点：</strong><br>均返回队列中第一个元素。<br><strong>不同点：</strong><br><code>poll</code>：弹出第一个元素（返回并删除），若为空，返回<code>null</code>。<br><code>peek</code>：返回第一个元素（返回不删除），若为空，返回<code>null</code>。<br><code>element</code>：返回第一个元素（返回不删除），若为空，<code>throw</code>异常<code>NoSuchElementException</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-level-or</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="队列" scheme="http://example.com/tags/%E9%98%9F%E5%88%97/"/>
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 155. 最小栈 (Java)</title>
    <link href="http://example.com/2020/05/12/LeetCode%20155.%20%E6%9C%80%E5%B0%8F%E6%A0%88%20(Java)/"/>
    <id>http://example.com/2020/05/12/LeetCode%20155.%20%E6%9C%80%E5%B0%8F%E6%A0%88%20(Java)/</id>
    <published>2020-05-12T16:01:53.000Z</published>
    <updated>2020-12-19T22:25:37.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h1><p><a href="https://leetcode-cn.com/problems/min-stack/">https://leetcode-cn.com/problems/min-stack/</a></p><h1 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h1><p>设计一个支持<code>push</code>，<code>pop</code>，<code>top</code>操作，并能在常数时间内检索到最小元素的栈。</p><ul><li><code>push(x)</code> —— 将元素 x 推入栈中。</li><li><code>pop()</code> —— 删除栈顶的元素。</li><li><code>top()</code> —— 获取栈顶元素。</li><li><code>getMin()</code> —— 检索栈中的最小元素。</li><li>*示例 1:**<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,-3,null,0,-2]</span><br><span class="line">解释：</span><br><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure></li><li>*提示**</li><li><code>pop</code>、<code>top</code> 和 <code>getMin</code>操作总是在<strong>非空栈</strong>上调用。<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1>数组是有序的，使用<strong>双指针法</strong>。<h1 id="需要注意的"><a href="#需要注意的" class="headerlink" title="需要注意的"></a>需要注意的</h1></li><li>常数时间。</li><li>注意空栈的情况<h1 id="解法一：两个栈"><a href="#解法一：两个栈" class="headerlink" title="解法一：两个栈"></a>解法一：两个栈</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y=<span class="number">0</span>;</span><br><span class="line">    Stack&lt;Integer&gt;  stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt;  stackm = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x); </span><br><span class="line">        <span class="keyword">if</span>(stackm.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            y=stackm.peek();</span><br><span class="line">            <span class="keyword">if</span>(y&gt;x)&#123;</span><br><span class="line">                stackm.push(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                stackm.push(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            stackm.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        stackm.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stackm.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="两个栈思路"><a href="#两个栈思路" class="headerlink" title="两个栈思路"></a>两个栈思路</h2>创建两个栈<code>stack</code>和<code>stackm</code>，当有新元素入栈时，直接进入<code>stack</code>，然后比较新元素与<code>stackm</code>栈顶元素的大小，判断进入<code>stackm</code>的元素的值；当有元素出栈时，<code>stack</code>和<code>stackm</code>中栈顶元素直接出栈。<br>无论何时，<code>stackm</code>的栈顶元素值为<code>stack</code>中元素的最小值。</li></ul><h1 id="解法二：一个栈"><a href="#解法二：一个栈" class="headerlink" title="解法二：一个栈"></a>解法二：一个栈</h1><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y=<span class="number">0</span>;</span><br><span class="line">    Stack&lt;Integer&gt;  stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">            y=stack.get(stack.size()-<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(y&gt;x)&#123;</span><br><span class="line">                stack.push(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            stack.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(x); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.get(stack.size()-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="一个栈思路"><a href="#一个栈思路" class="headerlink" title="一个栈思路"></a>一个栈思路</h2><p>创建栈<code>stack</code>，当有新元素入栈时，先判断新元素与栈顶元素的大小，将小的值入栈，之后新元素入栈，这样栈中数字两两成对。出栈时，两两出栈。<br>无论何时，<code>stackm</code>的第一层元素值为栈顶值<code>top</code>，第二层元素值为<code>stack</code>中元素的最小值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/min-stack/&quot;&gt;https://</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="栈" scheme="http://example.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 26. 删除排序数组中的重复项 (Java)</title>
    <link href="http://example.com/2020/05/10/LeetCode%2026.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%20(Java)/"/>
    <id>http://example.com/2020/05/10/LeetCode%2026.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%20(Java)/</id>
    <published>2020-05-10T18:13:39.000Z</published>
    <updated>2020-12-19T22:25:23.623Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h1><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/</a></p><h1 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h1><p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。<br><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums &#x3D; [1,1,2], </span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定 nums &#x3D; [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>说明</strong><br>为什么返回数值是整数，但输出的答案是数组呢?<br>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。<br>你可以想象内部操作如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len &#x3D; removeDuplicates(nums);</span><br><span class="line">&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>数组是有序的，使用<strong>双指针法</strong>。</p><h1 id="需要注意的"><a href="#需要注意的" class="headerlink" title="需要注意的"></a>需要注意的</h1><ul><li>返回最终数组的长度。</li><li>不要使用额外的数组空间。<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用a和b两个指针，a为没有重复的数字，b为后指针。</span></span><br><span class="line"><span class="comment">当b发现重复数字时加一，继续检查，当发现不重复数字时将值赋值给a+1。</span></span><br><span class="line"><span class="comment">直到遍历完数组中所有元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> b=<span class="number">1</span>;b&lt;nums.length;b++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[a]!=nums[b])&#123;</span><br><span class="line">                a++;</span><br><span class="line">                nums[a]=nums[b];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-duplicates-fr</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="指针" scheme="http://example.com/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>安卓数独游戏-3-界面绘制之自定义视图</title>
    <link href="http://example.com/2020/05/10/%E5%AE%89%E5%8D%93%E6%95%B0%E7%8B%AC%E6%B8%B8%E6%88%8F%EF%BC%88%E4%B8%89%EF%BC%89%E7%95%8C%E9%9D%A2%E7%BB%98%E5%88%B6%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%86%E5%9B%BE/"/>
    <id>http://example.com/2020/05/10/%E5%AE%89%E5%8D%93%E6%95%B0%E7%8B%AC%E6%B8%B8%E6%88%8F%EF%BC%88%E4%B8%89%EF%BC%89%E7%95%8C%E9%9D%A2%E7%BB%98%E5%88%B6%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%86%E5%9B%BE/</id>
    <published>2020-05-10T17:29:20.000Z</published>
    <updated>2020-12-31T15:27:45.295Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建自定义视图类"><a href="#创建自定义视图类" class="headerlink" title="创建自定义视图类"></a>创建自定义视图类</h1><p>创建自定义视图之前，需要创建自定义视图类，之后在资源文件<code>.xml</code>中作为一个元素插入。<br>创建自定义视图类时，需要继承<code>View</code>类，并重写类的构造函数。自定义视图类的基本结构如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">draw_sudoku_grid_easy</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">draw_sudoku_grid_easy</span><span class="params">(sudoku_play_easy sudoku_play_easy)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(sudoku_play_easy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">draw_sudoku_grid_easy</span><span class="params">(Context context, AttributeSet attributeSet)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context,attributeSet);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">draw_sudoku_grid_easy</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">draw_sudoku_grid_easy</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context,attrs,defStyleAttr);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="自定义视图类中重要函数"><a href="#自定义视图类中重要函数" class="headerlink" title="自定义视图类中重要函数"></a>自定义视图类中重要函数</h1><p>在数独游戏项目的自定义视图中，重写了View类的onDraw和onTouchEvent函数。</p><h2 id="onDraw函数"><a href="#onDraw函数" class="headerlink" title="onDraw函数"></a>onDraw函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span></span>&#123;</span><br><span class="line"><span class="comment">//Your code</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>每次函数重新绘制的时候，都会运行该函数。</p><h3 id="如何刷新自定义视图界面"><a href="#如何刷新自定义视图界面" class="headerlink" title="如何刷新自定义视图界面"></a>如何刷新自定义视图界面</h3><p>可以在自定义视图类中使用<code>invalidate</code>函数来重新调用<code>onDraw</code>函数，达到刷新界面的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invalidate();</span><br></pre></td></tr></table></figure><h2 id="onTouchEvent函数"><a href="#onTouchEvent函数" class="headerlink" title="onTouchEvent函数"></a>onTouchEvent函数</h2><p>项目中使用<code>onTouchEvent</code>函数对触摸事件进行处理。<br>使用<code>MotionEvent.ACTION_DOWN</code>和<code>MotionEvent.ACTION_UP</code>判断触摸事件类型，使用<code>event.getX()</code>和<code>event.getY()</code>得到触摸位置。</p><h1 id="自定义视图中的Toast消息框"><a href="#自定义视图中的Toast消息框" class="headerlink" title="自定义视图中的Toast消息框"></a>自定义视图中的Toast消息框</h1><p>安卓数独游戏中，需要在适当的时机给出用户提示，本项目使用了<code>Toast</code>的提示方式。<br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Toast toast=Toast.makeText(getContext(), <span class="string">&quot;&quot;</span>, <span class="number">800</span>);</span><br><span class="line">LinearLayout layout = (LinearLayout) toast.getView();</span><br><span class="line">TextView str = (TextView) layout.getChildAt(<span class="number">0</span>);</span><br><span class="line">str.setTextSize(<span class="number">30</span>);<span class="comment">//字体大小</span></span><br><span class="line">str.setTextColor(R.color.white);<span class="comment">//字体颜色</span></span><br><span class="line">toast.setText(<span class="string">&quot;Hint added!&quot;</span>);<span class="comment">//文本内容</span></span><br><span class="line">toast.setGravity(Gravity.CENTER, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//设置居中显示</span></span><br><span class="line">ImageView imageView= <span class="keyword">new</span> ImageView(getContext());</span><br><span class="line">imageView.setImageResource(R.drawable.about_icon);<span class="comment">//要显示的图标</span></span><br><span class="line">LinearLayout toastView = (LinearLayout) toast.getView();</span><br><span class="line">toastView.setOrientation(LinearLayout.VERTICAL);</span><br><span class="line">toastView.addView(imageView, <span class="number">0</span>);</span><br><span class="line">toast.show();</span><br></pre></td></tr></table></figure><p>效果如下图：<br><img src="https://upload-images.jianshu.io/upload_images/23211257-676c0b7953421b51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/23211257-676c0b7953421b51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/png;base64,666" alt="Toast.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;创建自定义视图类&quot;&gt;&lt;a href=&quot;#创建自定义视图类&quot; class=&quot;headerlink&quot; title=&quot;创建自定义视图类&quot;&gt;&lt;/a&gt;创建自定义视图类&lt;/h1&gt;&lt;p&gt;创建自定义视图之前，需要创建自定义视图类，之后在资源文件&lt;code&gt;.xml&lt;/code&gt;中</summary>
      
    
    
    
    <category term="安卓软件" scheme="http://example.com/categories/%E5%AE%89%E5%8D%93%E8%BD%AF%E4%BB%B6/"/>
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
    <category term="Sudoku" scheme="http://example.com/tags/Sudoku/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 236. 二叉树的最近公共祖先 (Java)</title>
    <link href="http://example.com/2020/05/10/LeetCode%20236.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%20(Java)/"/>
    <id>http://example.com/2020/05/10/LeetCode%20236.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%20(Java)/</id>
    <published>2020-05-10T14:01:33.000Z</published>
    <updated>2020-12-19T22:25:40.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h1><p><a href="%5Bhttps://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/%5D(https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)"><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></a></p><h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<br>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]<br><img src="https://upload-images.jianshu.io/upload_images/23211257-80c5fb1c95617e35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/23211257-80c5fb1c95617e35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/png;base64,666" alt="binarytree.png"><br><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉树中。</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>LCA问题。<br>使用递归的思想，对二叉树进行后序遍历。<br>（1）当左右子树返回值均为null，说明p、q均不在子树中，返回null。<br>（2）当左右子树中有一个树返回了值，说明p、q有一个在子树中，返回该值。<br>（3）当左右子树均有返回值，说明该节点是最近的公共祖先，返回节点值。</p><h1 id="需要注意的"><a href="#需要注意的" class="headerlink" title="需要注意的"></a>需要注意的</h1><ul><li>当一个节点<code>r</code>为<code>p</code>和<code>q</code>的最近公共祖先时，<code>p</code>和<code>q</code>分别在r的左右两侧。</li><li>一个节点可以是自己的祖先。</li><li>因为不是二叉搜索树（BST），所以直接用后序遍历的方法。<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>||root==p||root==q)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left=lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode right=lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="comment">//左树是空值，返回右节点；右数是空值，返回左节点，否则返回根节点。</span></span><br><span class="line">        <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : right == <span class="keyword">null</span> ? left : root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;%5Bhttps://leetcode-cn.com/problems/lowest-common-anc</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>安卓数独游戏-2-界面绘制之约束布局-ConstraintLayout</title>
    <link href="http://example.com/2020/05/09/%E5%AE%89%E5%8D%93%E6%95%B0%E7%8B%AC%E6%B8%B8%E6%88%8F%EF%BC%88%E4%BA%8C%EF%BC%89%E7%95%8C%E9%9D%A2%E7%BB%98%E5%88%B6%E4%B9%8B%E7%BA%A6%E6%9D%9F%E5%B8%83%E5%B1%80-ConstraintLayout/"/>
    <id>http://example.com/2020/05/09/%E5%AE%89%E5%8D%93%E6%95%B0%E7%8B%AC%E6%B8%B8%E6%88%8F%EF%BC%88%E4%BA%8C%EF%BC%89%E7%95%8C%E9%9D%A2%E7%BB%98%E5%88%B6%E4%B9%8B%E7%BA%A6%E6%9D%9F%E5%B8%83%E5%B1%80-ConstraintLayout/</id>
    <published>2020-05-09T17:44:36.000Z</published>
    <updated>2020-12-31T15:27:34.375Z</updated>
    
    <content type="html"><![CDATA[<p>本项目使用<strong>约束布局</strong>和<strong>自定义视图</strong>相结合的方法绘制界面。<br>这篇文章主要介绍了<code>约束布局</code>，即<code>ConstraintLayout</code>。</p><h1 id="新建布局资源文件"><a href="#新建布局资源文件" class="headerlink" title="新建布局资源文件"></a>新建布局资源文件</h1><p>在<code>res-&gt;layout</code>文件夹中击右键，创建一个<code>Root element</code>为<code>androidx.constraintlayout.widget.ConstraintLayout</code>的<code>Drawable Resource File</code>，点击确定，会发现<code>src</code>目录多了<code>.java</code>文件和<code>.xml</code>文件。<br><img src="https://upload-images.jianshu.io/upload_images/23211257-e781795430325d38.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/23211257-e781795430325d38.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/png;base64,666" alt="Create xml.PNG"></p><h1 id="配置布局中元素"><a href="#配置布局中元素" class="headerlink" title="配置布局中元素"></a>配置布局中元素</h1><p>Android Studio为开发者提供了三种开发模式：</p><ul><li><p>纯代码</p></li><li><p>代码与预览混合</p></li><li><p>图形用户界面</p></li></ul><p>开发者可以通过点击右上角的三个图标自由切换，选择适合自己的模式。<br><img src="https://upload-images.jianshu.io/upload_images/23211257-d6ab63387db7038a.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/23211257-d6ab63387db7038a.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/png;base64,666" alt="三种开发模式.PNG"></p><h2 id="纯代码模式"><a href="#纯代码模式" class="headerlink" title="纯代码模式"></a>纯代码模式</h2><p>只有代码，不能实时预览，除非编译屏幕很小，否则不建议使用这个模式。<br><img src="https://upload-images.jianshu.io/upload_images/23211257-8d89ec7ed313ae83?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/23211257-8d89ec7ed313ae83?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/png;base64,666" alt="纯代码模式.PNG"></p><h2 id="代码与预览混合模式"><a href="#代码与预览混合模式" class="headerlink" title="代码与预览混合模式"></a>代码与预览混合模式</h2><p>左边修改代码，右边实时预览界面，是开发本项目中最常使用的模式。<br><img src="https://upload-images.jianshu.io/upload_images/23211257-5811d450dbb528bd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/23211257-5811d450dbb528bd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/png;base64,666" alt="代码与预览混合模式.png"></p><h2 id="图形用户界面模式"><a href="#图形用户界面模式" class="headerlink" title="图形用户界面模式"></a>图形用户界面模式</h2><p>通过对元素进行拖拽和直接对元素进行配置等方法进行布局设置，最简单的一种模式，但是博主认为如果熟悉代码功能之后，直接修改代码更加方便。<br>如图所示，左侧为可以添加的元素，可以通过拖拽方式添加；中间为当前界面的预览；右侧可以修改约束项。<br><img src="https://upload-images.jianshu.io/upload_images/23211257-dd7e535af5916abc?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/23211257-dd7e535af5916abc?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/png;base64,666" alt="图形用户界面模式.png"></p><h1 id="约束布局的关键代码"><a href="#约束布局的关键代码" class="headerlink" title="约束布局的关键代码"></a>约束布局的关键代码</h1><p>下面以对按钮的设置为例子，对约束布局的关键代码做出解释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">  android:id&#x3D;&quot;@+id&#x2F;new_game_button&quot;&#x2F;&#x2F;该元素的id</span><br><span class="line">  android:layout_width&#x3D;&quot;240dp&quot;&#x2F;&#x2F;元素的宽</span><br><span class="line">  android:layout_height&#x3D;&quot;50dp&quot;&#x2F;&#x2F;元素的高</span><br><span class="line">  android:text&#x3D;&quot;@string&#x2F;new_game&quot;&#x2F;&#x2F;按钮内内容，可以直接输入String，也可以使用String变量</span><br><span class="line">  style&#x3D;&quot;?android:attr&#x2F;borderlessButtonStyle&quot;&#x2F;&#x2F;无边框按钮风格</span><br><span class="line">  app:layout_constraintBottom_toBottomOf&#x3D;&quot;parent&quot;&#x2F;&#x2F;该元素的底部是“parent”的底部</span><br><span class="line">  app:layout_constraintEnd_toEndOf&#x3D;&quot;parent&quot;&#x2F;&#x2F;同理</span><br><span class="line">  app:layout_constraintStart_toStartOf&#x3D;&quot;parent&quot;&#x2F;&#x2F;同理</span><br><span class="line">  app:layout_constraintTop_toBottomOf&#x3D;&quot;@id&#x2F;sudoku_logo&quot;&#x2F;&#x2F;同理</span><br><span class="line">  android:textAllCaps&#x3D;&quot;false&quot;&#x2F;&#x2F;如果没有这句话按钮上的字母会全部大写</span><br><span class="line">  android:background&#x3D;&quot;@drawable&#x2F;button_background_control&quot;&#x2F;&#x2F;按钮背景设置</span><br><span class="line">  app:layout_constraintHorizontal_bias&#x3D;&quot;0.5&quot;&#x2F;&#x2F;按钮在水平方向，左右两侧空白比例</span><br><span class="line">  app:layout_constraintVertical_bias&#x3D;&quot;0.3&quot;&#x2F;&#x2F;按钮在垂直方向，左右两侧空白比例</span><br><span class="line">&#x2F;&gt;</span><br></pre></td></tr></table></figure><h2 id="按钮上字母全部大写问题"><a href="#按钮上字母全部大写问题" class="headerlink" title="按钮上字母全部大写问题"></a>按钮上字母全部大写问题</h2><p>如果采用默认设置，使用<code> android:text=&quot;String&quot;</code>后，按钮上字母将会全部大写。可以在xml文件中按钮元素的设置部分，添加<code>android:textAllCaps=&quot;false&quot;</code>,这样按钮上的字母的大小写将会和<code>String</code>中的字母大小写一致。</p><h2 id="元素位置设置"><a href="#元素位置设置" class="headerlink" title="元素位置设置"></a>元素位置设置</h2><p>使用<code>app:layout_constraintA_toBOf=&quot;C&quot;</code>设置元素的位置，其中<code>A</code>和<code>B</code>可以为<code>Start</code>，<code>End</code>，<code>Top</code>，<code>Bottom</code>，<code>C</code>为需要作为参考的元素，可以为<code>parent</code>或其他元素的<code>id</code>。例如<code>app:layout_constraintTop_toBottomOf=&quot;@id/sudoku_logo&quot;</code>代表该元素的顶部是<code>sudoku_logo</code>的底部。<br>最后通过<code>app:layout_constraintHorizontal_bias=&quot;n&quot;</code>和<code>app:layout_constraintVertical_bias=&quot;n&quot;</code>来设置元素水平方向或垂直方向两侧的空白比例。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本项目使用&lt;strong&gt;约束布局&lt;/strong&gt;和&lt;strong&gt;自定义视图&lt;/strong&gt;相结合的方法绘制界面。&lt;br&gt;这篇文章主要介绍了&lt;code&gt;约束布局&lt;/code&gt;，即&lt;code&gt;ConstraintLayout&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id=&quot;新建</summary>
      
    
    
    
    <category term="安卓软件" scheme="http://example.com/categories/%E5%AE%89%E5%8D%93%E8%BD%AF%E4%BB%B6/"/>
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
    <category term="Sudoku" scheme="http://example.com/tags/Sudoku/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 69. x的平方根 (Java)</title>
    <link href="http://example.com/2020/05/09/LeetCode%2069.%20x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9%20(Java)/"/>
    <id>http://example.com/2020/05/09/LeetCode%2069.%20x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9%20(Java)/</id>
    <published>2020-05-09T01:01:33.000Z</published>
    <updated>2020-12-19T22:25:28.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h1><p><a href="https://leetcode-cn.com/problems/sqrtx">https://leetcode-cn.com/problems/sqrtx</a></p><h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><p>实现 int sqrt(int x) 函数。<br>计算并返回 x 的平方根，其中 x 是非负整数。<br>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br><span class="line">说明: 8 的平方根是 2.82842..., </span><br><span class="line">     由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>第一眼肯定是<code>return Math.sqrt(x)</code>哈哈哈哈。。。。<br>言归正传，需要用到二分法。<br>结果范围肯定在0到x之间，所以使用<strong>二分法</strong>。</p><h1 id="需要注意的"><a href="#需要注意的" class="headerlink" title="需要注意的"></a>需要注意的</h1><ul><li>去除特殊值1。</li><li>不能使用<code>mid * mid &gt; x</code>，只能使用<code>x / mid &lt; mid</code>，为了防止int数太大溢出。<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = x;</span><br><span class="line">        <span class="keyword">while</span>(min&lt;max-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (max+min)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(x/mid&lt;mid)&#123;</span><br><span class="line">                max=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                min=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sqrtx&quot;&gt;https://leetc</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="二分法" scheme="http://example.com/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>安卓数独游戏-1-隐藏AndroidActionBar</title>
    <link href="http://example.com/2020/05/08/%E5%AE%89%E5%8D%93%E6%95%B0%E7%8B%AC%E6%B8%B8%E6%88%8F%EF%BC%88%E4%B8%80%EF%BC%89%E9%9A%90%E8%97%8FAndroidActionBar/"/>
    <id>http://example.com/2020/05/08/%E5%AE%89%E5%8D%93%E6%95%B0%E7%8B%AC%E6%B8%B8%E6%88%8F%EF%BC%88%E4%B8%80%EF%BC%89%E9%9A%90%E8%97%8FAndroidActionBar/</id>
    <published>2020-05-08T18:04:56.000Z</published>
    <updated>2020-12-31T15:27:50.784Z</updated>
    
    <content type="html"><![CDATA[<p>在开发Android应用时，默认会有如图所示的一栏大大的ActionBar：<br><img src="https://upload-images.jianshu.io/upload_images/23211257-8d50ed4e0d24cff2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/23211257-8d50ed4e0d24cff2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/png;base64,666" alt="有Actionbar.png"></p><p>如果想要去除ActionBar，只需要在页面中的<code>onCreate</code>函数中加入<code>getSupportActionBar().hide();</code>即可，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">  super.onCreate(savedInstanceState);</span><br><span class="line">  getSupportActionBar().hide(); &#x2F;&#x2F;隐藏ActionBar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下图：<br><img src="https://upload-images.jianshu.io/upload_images/23211257-0a87d20bf04afa47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/23211257-0a87d20bf04afa47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/png;base64,666" alt="无ActionBar.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在开发Android应用时，默认会有如图所示的一栏大大的ActionBar：&lt;br&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/23211257-8d50ed4e0d24cff2.png?imageMog</summary>
      
    
    
    
    <category term="安卓软件" scheme="http://example.com/categories/%E5%AE%89%E5%8D%93%E8%BD%AF%E4%BB%B6/"/>
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
    <category term="Sudoku" scheme="http://example.com/tags/Sudoku/"/>
    
  </entry>
  
  <entry>
    <title>安卓数独游戏-0-</title>
    <link href="http://example.com/2020/05/08/%E5%AE%89%E5%8D%93%E6%95%B0%E7%8B%AC%E6%B8%B8%E6%88%8F%EF%BC%88%E9%9B%B6%EF%BC%89/"/>
    <id>http://example.com/2020/05/08/%E5%AE%89%E5%8D%93%E6%95%B0%E7%8B%AC%E6%B8%B8%E6%88%8F%EF%BC%88%E9%9B%B6%EF%BC%89/</id>
    <published>2020-05-08T18:01:41.000Z</published>
    <updated>2020-12-31T15:27:40.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>历时半年，终于项目–安卓数独游戏（Android Sudoku Game)。 在材料提交后，准备再次从头复习一遍软件开发的过程，同时对项目中遇到的问题和用到的方法做一个记录。</p><hr><h1 id="游戏简介"><a href="#游戏简介" class="headerlink" title="游戏简介"></a>游戏简介</h1><p>数独是一个数学逻辑游戏，它包括9x9个格子，玩家需要通过已知数字推断出剩余数字，来保证行、列和九宫格包括不重复的数字1-9。<br>除数独游戏的基础游戏功能外，本项目还实现了分享，保存，标记，提示，昼夜模式切换和点击音效设置等功能。</p><hr><h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><ul><li>集成开发工具：Android Studio 3.6.2</li><li>辅助开发工具：Gradle 5.6.4, Android Virtual Device</li><li>开发语言：Java 13.0.1, XML</li><li>测试环境：Android 4.0.3 +</li></ul><hr><h1 id="关于游戏"><a href="#关于游戏" class="headerlink" title="关于游戏"></a>关于游戏</h1><p>当前安卓数独游戏已经发布到Google Play Store，更多详情如下：</p><ul><li>谷歌商店：<a href="https://play.google.com/store/apps/details?id=sudokugame.example.sudoku">数独游戏</a></li><li>游戏更新记录：<a href="https://sites.google.com/view/sudoku-game-version-history">Sudoku version history</a></li><li>Email：<a href="iyuhangli@outlook.com">iyuhangli@outlook.com</a></li><li>Github：<a href="#">等待上传中</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;历时半年，终于项目–安卓数独游戏（Android Sudoku Game)。 在材料提交后，准备再次从头复习一遍软件开发的过程，同时对项目中</summary>
      
    
    
    
    <category term="安卓软件" scheme="http://example.com/categories/%E5%AE%89%E5%8D%93%E8%BD%AF%E4%BB%B6/"/>
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
    <category term="Sudoku" scheme="http://example.com/tags/Sudoku/"/>
    
  </entry>
  
</feed>
